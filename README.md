# Внутренние, вложенные, локальные и анонимные классы


## Вложенные классы (внутренние статические)

**Вложенный класс** - это класс, определенный внутри другого класса с модификатором `static`. Вложенный класс
является членом внешнего класса так же, как и статическое поле или метод.

````java

public class OuterClass {
    public static class StaticNestedClass {
        // тело вложенного класса
    }
}

````
### Для чего нужно?

Вложенные классы используются для группировки классов, которые тесно связаны друг с другом.

**Основные причины использования:**
1. **Инкапсуляция** - если класс используется только одним другим классом
2. **Улучшение струтуры кода** - позволяет сгруппировать связанные классы вместе, не создавая лишних классов
3. **Организация пространства имен** - помогает избежать конфликтов имен классов

### Пример исользования
```java

public class LinkedList {

    private Node head;

    // Статический вложенный класс Node
    public static class Node {
        int data;
        Node next;

        public Node(int data) {
            this.data = data;
        }
    }

    public void add(int data) {
        // Реализация добавления элемента в список
    }

    // Другие методы LinkedList
}

```


### Особенности

- **Статический контент** - статический вложенный класс не зависит от экземпляра внешнего класса
- **Доступ к члена внешнего класса:**
    1. **Вложенный класс может обращаться только к статическим членам внешнего класса**
    2. **Не имеет доступа к нестатическим полям и методам внешнего класса** (для получения доступа нужно сначала создать
экземпляр внешнего класса)
- **Создание экземпляра вложенного класса** не требует создания экземляра внешнего класса
- Создается с использование имени внешенго класса `OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();`

### Ограничения
- Нет прямого доступа к нестатическим полям и методам внешнего класса
- Не может переопределять нестатические методы внешенго класса

### Возможность наследования?
1. Вложенный класс может наследоваться от других классов и реализовывать интерфейсы
```java

public class OuterClass {

    public static class StaticNestedClass extends SomeClass implements SomeInterface {
        // Реализация
    }
}

```
2. Другие классы могут наследоваться от статического вложенного класса
```java

public class SubClass extends OuterClass.StaticNestedClass {
    // Реализация
}

```
### Модификаторы доступа
Вложенный класс может иметь следующие модификаторы доступа: `public`, `protected`, `private` и дефолтный

### Доступ внешнего класса к статическому вложенному
Внешний класс может создать экземпляр вложенного класса и обращаться к его членам

```java

public class OuterClass {

    public void useNestedClass() {
        StaticNestedClass nested = new StaticNestedClass();
        nested.display();
    }

    public static class StaticNestedClass {
        public void display() {
            System.out.println("Метод статического вложенного класса");
        }
    }
}

```

### Дополнительные особенности 
- **Вложенные классы и память:** вложенный класс не хранит неявную ссылку на экземпляр внешенго класса.
- **Практическое применение:**
    1. **Утилитные классы** - если класс используется только внутри другого класса, его можно сделать вложенным классом
    2. **Builder** - вложенные классы часто используются для реализации паттерна "Строитель" 
```java

public class Person {

    private String name;
    private int age;

    private Person(Builder builder) {
        this.name = builder.name;
        this.age = builder.age;
    }

    public static class Builder {
        private String name;
        private int age;

        public Builder setName(String name) {
            this.name = name;
            return this;
        }

        public Builder setAge(int age) {
            this.age = age;
            return this;
        }

        public Person build() {
            return new Person(this);
        }
    }
}

// Использование:
Person person = new Person.Builder()
                    .setName("John")
                    .setAge(30)
                    .build();

```

## Внутренние классы
**Внутренний класс** - класс который объвляется внутри другого класса без модификатора `static`. Внутренний класс
является членом внешнего класса и связан с его экземпляром.

```java

public class OuterClass {
    public class InnerClass {
        // тело внутреннего класса
    }
}

```

### Для чего нужны
1. **Инкасулировать** вспомогательные классы внутри внешних классов
2. **Получить доступы** к членам внешнего класса, включая приватные поля и методы
3. **Организация кода**, который логически связан с внешним классом, в одном месте
4. **Сократить** количество файлов в проекте, если внутренний класс используется только внешним классом
5. **Реализация паттернов проектирования**, где внутренний класс тесно связан с внешним (Iterator, Observer)

### Пример использования

```java

public class DataStructure {

    private int[] array = {1, 2, 3, 4, 5};

    public class DataStructureIterator {
        private int index = 0;

        public boolean hasNext() {
            return index < array.length;
        }

        public int next() {
            return array[index++];
        }
    }

    public DataStructureIterator getIterator() {
        return new DataStructureIterator();
    }
}

```
### Особенности внутренних классов 
- **Ссылка на внешний класс** - внутренний класс неявно содержит ссылку на экземпляр внешнего класса. Это позволяет ему
обращаться ко всем членам внешнего класса, включая приватные поля и методы
- **Создание экземпляра внутреннего класса**: чтобы создать экземпляр внутреннего класса, сначала необходимо создать
экземпляр внешенго класса

```java

OuterClass outer = new OuterClass();
OuterClass.InnerClass inner = outer.new InnerClass();

```
- Если **имена полей или методов** внутреннего и внешнего классов совпадают, можно использовать `OuterClass.this` для 
обрашения к членам внешнего класса
- **Внешний класс** не может напрямую обращаться к членам внутреннего класса, если не явялются публичными или защищенными

### Ограничения
1. Поскольку внутренний класс содержит неявную ссылку на экземпляр внешенго класса, это может привести к дополнительным
затратам памяти
2. Возможны **утечки памяти** при неправильном использовании внутреннего класса (например, сохраняется ссылка на внутрений
класс после того, как внешний класс больше не нужен)

### Модификаторы доступа
Внутренний класс может иметь следущие модификаторы: `public`, `protected`, `private` и дефолтный

### Статические члены
Внутренний класс не может содержать статических переменных или методов, кроме статических констант `static final`

**Почему нестатический внутренний класс не может содержать статических переменных или методов, 
кроме статических констант `static final`?**

1. **Понимание нестатических внутренних классов**
    - Нестатический внутренний класс (inner class) — это класс, объявленный внутри другого класса без 
модификатора `static`.
    - **Связь с внешним классом:**
        - Каждый экземпляр внутреннего класса неразрывно связан с экземпляром внешнего класса.
        - Внутренний класс имеет неявную ссылку на свой внешний объект, что позволяет ему обращаться ко всем членам внешнего 
класса, включая приватные.
2. **Статические члены в классе**
    - Статические переменные и методы принадлежат самому классу, а не его экземплярам.
    - Они существуют независимо от экземпляров и загружаются в память при загрузке класса.
3. **Конфликт между статическими членами и внутренними классами**
    - **Проблема с контекстом:**
        - Поскольку внутренний класс всегда связан с конкретным экземпляром внешнего класса, разрешение объявлять статические 
члены внутри него создало бы двусмысленность.
        - Статические члены должны быть доступны без создания экземпляра класса, но внутренний класс не может существовать 
без экземпляра внешнего класса
    - **Логическое противоречие:**
        - Если бы внутренний класс мог содержать статические переменные или методы, возник бы вопрос: как обращаться к 
этим статическим членам без создания экземпляра внешнего класса?
        - Это нарушило бы фундаментальные принципы объектно-ориентированного программирования и модель памяти Java.
4. Исключение для `static final` констант
    - Статические финальные константы (поля, объявленные как `static final`) являются компилируемыми константами.
    - **Почему они разрешены:**
        - `static final` константы компилируются как константы времени компиляции.
        - Они встраиваются (inlined) в байт-код во время компиляции и не требуют фактического статического 
контекста во время выполнения.
        - акие константы не создают проблем с контекстом экземпляра, поскольку они не зависят от экземпляров или 
классов во время выполнения.


### Доступ внешнего класса к членам внутреннего класса:
Внешний класс может создавать экземпляры внутреннего класса и обращаться к его членам, если они доступны
по модификаторам доступа.

### Использование в статическом контексте:
Нельзя создавать экземпляры внутреннего класса из статических методов внешнего класса без экземпляра внешнего класса.
```java

public class OuterClass {
    public class InnerClass {
        // ...
    }

    public static void staticMethod() {
        // Нельзя сделать так:
        // InnerClass inner = new InnerClass(); // Ошибка компиляции
    }
}

```

## Локальные классы
Локальный класс - это класс, который объявлен внутри метода, конструктора или блока кода. Он называется локальным
потому что область его видимости ограничена блоком, в котором он объявлен.

```java

public class OuterClass {
    public void someMethod() {
        // Локальный класс внутри метода
        class LocalClass {
            // Тело локального класса
        }

        // Использование локального класса
        LocalClass localInstance = new LocalClass();
    }
}

```

### Для чего нужны?
1. **Инкапсуляции вспомогательных классов:** Если класс используется только в одном методе или блоке, логично 
объявить его там, чтобы не засорять пространство имен всего класса.


### Примеры использования

**Пример 1: Использование локального класса внутри метода**

```java

public class OuterClass {

    public void printNumbers() {
        int start = 1;
        int end = 5;

        // Локальный класс
        class NumberPrinter {
            public void print() {
                for (int i = start; i <= end; i++) {
                    System.out.println(i);
                }
            }
        }

        // Создание экземпляра и вызов метода
        NumberPrinter printer = new NumberPrinter();
        printer.print();
    }
}


public class Main {
    public static void main(String[] args) {
        OuterClass outer = new OuterClass();
        outer.printNumbers();
        // Вывод:
        // 1
        // 2
        // 3
        // 4
        // 5
    }
}


```

**Пример 2: Использование локального класса для обработки событий**

```java

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JButton;

public class OuterClass {

    public void createButton() {
        JButton button = new JButton("Click Me");

        // Локальный класс для обработки события нажатия кнопки
        class ButtonClickListener implements ActionListener {
            @Override
            public void actionPerformed(ActionEvent e) {
                System.out.println("Кнопка была нажата!");
            }
        }

        // Установка обработчика события
        button.addActionListener(new ButtonClickListener());
    }
}

```

### Особенности:
- **Область видимости:** Локальный класс виден только внутри метода, конструктора или блока, в котором он объявлен
- **Доступ к переменным:**
    - Локальный класс имеет доступ ко всем членам внешнего класса, включая приватные поля и методы.
    - Может обращаться к локальным переменным метода, если они финальные или эффективно финальные.
        - **Эффективно финальная переменная** — это переменная, значение которой не изменяется после инициализации, 
      даже если она не объявлена с ключевым словом `final`.
- Локальный класс не может содержать статических переменных или методов, за исключением статических финальных констант

### Ограничения
1. **Доступ к локальным переменным:**
    - Если вы хотите, чтобы локальный класс использовал переменную из метода, эта переменная должна быть 
   финальной или эффективно финальной.
    - Это сделано для обеспечения корректной работы локального класса после завершения метода, в котором он объявлен.
2. **Модификаторы доступа:**
    - Нельзя использовать модификаторы доступа (`public`, `private`, `protected`) при объявлении локального класса.
    - Также нельзя использовать модификаторы `static`, `abstract`, `final`, `strictfp`
3. Локальный класс не может содержать статических методов или полей, кроме `static final` констант.



## Анонимные классы
**Анонимный класс** — это класс без имени, который объявляется и создается одновременно в выражении new.
Анонимные классы обычно используются для создания объектов, которые реализуют интерфейсы или 
наследуются от классов, с возможностью переопределения методов на месте.


### Для чего нужны?
1. **Упрощения кода:** Позволяют создать одноразовую реализацию интерфейса или класса без необходимости объявлять 
отдельный класс с именем
2. **Локализации кода:** Код, связанный с определенной задачей, находится в одном месте, что улучшает читаемость.
3. **Быстрого переопределения методов:** Можно быстро переопределить методы существующего класса или интерфейса.


**Пример 1: Использование с интерфейсом Runnable**

```java

public class Main {
    public static void main(String[] args) {
        // Создаем новый поток с помощью анонимного класса
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("Поток запущен с использованием анонимного класса");
            }
        });
        thread.start();
    }
}

```

**Пример 2: Использование с классом MouseAdapter**

```java

import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class MyComponent extends JComponent {
    public MyComponent() {
        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                System.out.println("Мышь нажата на компоненте");
            }
        });
    }
}

```

**Пример 3: Переопределение метода существующего класса**

```java

public class Greeting {
    public void sayHello() {
        System.out.println("Hello!");
    }
}

public class Main {
    public static void main(String[] args) {
        Greeting greeting = new Greeting() {
            @Override
            public void sayHello() {
                System.out.println("Привет!");
            }
        };
        greeting.sayHello(); // Вывод: Привет!
    }
}

```

### Особенности

- **Отсутствие имени:** Анонимные классы не имеют имени, поэтому их нельзя использовать повторно.
- **Одновременное создание и объявление:** Анонимный класс объявляется и создается одновременно в одном выражении new.
- **Ограничения на наследование:**
    - Анонимный класс может расширять только один класс или реализовывать один интерфейс
    - Нельзя одновременно наследоваться от класса и реализовывать интерфейс.
- **Могут переопределять методы:** Анонимный класс может переопределять методы родительского класса или интерфейса.
- **Доступ к переменным:**
    - Анонимный класс имеет доступ к финальным или эффективно финальным локальным переменным окружающего метода.
    - Может обращаться ко всем членам внешнего класса, включая приватные.

### Ограничения
- **Нельзя объявлять конструкторы:** Поскольку у анонимного класса нет имени, нельзя объявить конструктор. Однако можно использовать 
инициализатор экземпляра для инициализации.

```java

SomeClass obj = new SomeClass() {
    // Инициализатор экземпляра
    {
        // Инициализация полей
    }
};

```
- Нельзя объявлять статические члены: Анонимный класс не может содержать статические методы или поля, 
кроме `static final` констант.
- Один экземпляр: Анонимный класс обычно используется для создания одного экземпляра, поскольку он не имеет имени и не 
может быть использован повторно.

### Применение анонимных классов
1. **Обработчики событий:** В GUI-приложениях для обработки событий (например, нажатия кнопки)

```java
button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("Кнопка нажата");
    }
});
```
2. **Потоки исполнения:** Быстрое создание потоков с переопределением метода run().
```java

new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("Поток запущен");
    }
}).start();

```

4. **Сортировка коллекций:** Использование анонимных классов для создания компараторов

```java

List<String> list = new ArrayList<>();
Collections.sort(list, new Comparator<String>() {
    @Override
    public int compare(String o1, String o2) {
        return o1.length() - o2.length();
    }
});

```


